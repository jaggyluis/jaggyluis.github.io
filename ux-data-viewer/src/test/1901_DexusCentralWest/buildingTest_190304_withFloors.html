<html lang="en">
  <head>
    <title>Mockup</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src="https://unpkg.com/deck.gl@^6.2.0/deckgl.min.js"></script>
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v0.50.0/mapbox-gl.js"></script>
    <link rel="stylesheet" type="text/css" href="https://api.tiles.mapbox.com/mapbox-gl-js/v0.50.0/mapbox-gl.css">
	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
	<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,700&amp;lang=en" />
    <script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
	<script src="numeral.min.js"></script>
	<script src="FileSaver.js"></script>

    <style type="text/css">
      body { font-family: 'Roboto', Helvetica, Arial, sans-serif; width: 100vw; height: 100vh; margin: 0; }

      #control-panel {
	  position: absolute;
	  background: #fff;
	  top: 120; left: 0;
	  margin: 12px;
	  padding: 10px ;
	  font-size: 12px;
	  line-height: 1.5;
	  }

      label { display: inline-block; width: 30px; font-size: 14px; vertical-align: top; }

	  .hoverWrapper:hover #hoverShow1 {
		 display: block;
		}

		.hoverWrapper #hoverShow1 {
		 display: none;
		}
		/*Top left title*/
		#nbhd-title {position: absolute; background: #fff; color: black; top: 0; left: 0; margin: 12px; padding: 0px 20px 0px 20px; font-size: 25px; font-weight: bold; line-height: 1; z-index:2;}

		/*Right hand dashboard*/
		#dashboard{
		  right: 0;
		  top: 0;
		  width:400px;
		  height:100%;
		  //background:white;
		  background: linear-gradient(
		  to left,
		  rgba(255, 255, 255, 1),
		  rgba(255, 255, 255, 0.9)
		  );
		  position:absolute;
		  padding: 20px;
		  //z-index: 2;
		  font-size: 20px;
		  font-weight: bold;
		  //white-space: pre;
		}
		#gradientOverlay{
		  left: 0;
		  top: 0;
		  width:100%;
		  height:10%;
		  position:absolute;
		  background: linear-gradient(
		  rgba(0, 174, 255, 0.15),
		  rgba(255, 255, 255, 0.0)
		  );
          )
		}
		#quotediv{
		  right: 20;
		  bottom: 50;
		  width:30%;
		  position:absolute;
		  padding: 15px;
		  //z-index: 2;
		  font-size: 20px;
		  font-weight: bold;
		  text-align: right;
		  display: none;
		  //white-space: pre;
		  overflow-wrap: normal;
		  background-color: rgba(0,0,0, 0.9);
		  color: white;
		  z-index: 3;
		}
		#quotedivp{
		padding-right: 25px;
		}
		#map-main {
			position: absolute;
			left: 0;
			height: 100%;
			width: 100%;
			background-color: #d6d6d6;
			//border: 1px solid black;
			//z-index: 0;
			mix-blend-mode: multiply;
			isolation: 'isolate';
		}
		#map-main-overlay {
			position: absolute;
			left: 0;
			height: 100%;
			width: 70%;
			background-color: 'none';
			//z-index: 1;
		}

		.material-icons.md-48 { font-size: 40px; }
		.material-icons {
			display: inline-flex;
			align-items: center;
			justify-content: center;
			vertical-align: bottom;
		}
		.table .td {
			vertical-align: bottom;
		}

		.legend {
			background-color: #fff;
			border-radius: 0px;
			font-size: 12px;
			bottom: 40px;
			box-shadow: 0 1px 2px rgba(0,0,0,0.10);
			padding: 10px;
			position: absolute;
			left: 12px;
			z-index: 1;
		}
		.legend div span {
			border-radius: 50%;
			display: inline-block;
			height: 10px;
			margin-right: 5px;
			width: 10px;
		}
		.legend div span .metro {
			display: inline-block;
			height: 10px;
			margin-right: 5px;
			width: 10px;
		}
		#tooltip:empty {
		  display: none;
		}
		#tooltip {
		  font-family: Helvetica, Arial, sans-serif;
		  font-size: 11px;
		  position: absolute;
		  padding: 4px;
		  margin: 8px;
		  background: rgba(0, 0, 0, 0.8);
		  color: #fff;
		  max-width: 300px;
		  font-size: 10px;
		  z-index: 21;
		  pointer-events: none;
		}
		.mapboxgl-popup {
			max-width: 300px;
			font: 11px 'Helvetica Neue', Arial, Helvetica, sans-serif;
		}


   </style>
  </head>

  <body>


	<div id="map-main">
	<!-- TOOLTIP-->
	<!--<div id="tooltip">test</div>-->
	</div>

	<!--<div id="gradientOverlay">&nbsp</div>-->

	<!--NBHD TITLE------------------------------------------------------------------------ -->
	<div id="nbhd-title">
	<p id="nbhd-title-text">Dexus Central West </br>MOCKUP</p>
	</div>

	<div id="control-panel">
			Metrics: Area</br>
			<select id='prop_total' name='prop_total'>
				<!--
				<option value='floorplate_area'>Floorplate area</option>
				<option value='floorplate_area_inrange'>Floorplate area (in range)</option>
				<option value='height'>Height</option>
				<option value='no_value'>No metric</option>
				-->
			</select>
			</br></br>
			Metrics: Percentage Area</br>
			<select id='prop_percentages' name='prop_percentages'><select></br></br>
			Metrics: Employees</br>
			<select id='prop_empl' name='prop_empl'><select></br></br>
			<input type="button" class="w3-button w3-white" onclick="addLayerMAJORUSE()" value="Major Use"></br>
			<input type="button" class="w3-button w3-white" onclick="addLayerPODIUM()" value="Podium/Tower"></br>
			<input type="button" class="w3-button w3-white" onclick="addLayerSATISFIED()" value="Criteria"></br>
			<input type="button" class="w3-button w3-white" onclick="addLayerNLA()" value="NLA"></br>
			<!--
			<select id='prop2' name='prop2'>
				<option value='mapstyle1'>Mapbox map</option>
				<option value='mapstyle2'>Grey and white</option>
			</select>
			-->
			</br></br>
			<input type="button" class="w3-button w3-black" onclick="takeScreenshot()" value="screenshot"></br></br>
			<p>View: <span id="viewNumber">View 1</span></p>
			<input type="button" class="w3-button w3-black" onclick="logCamera()" value="log view">
			<input type="button" class="w3-button w3-black" onclick="switchView()" value="switch view">
			<p>Cutoff</p>
			Lower Bound: <input type="number" step="any" min="0" max="100000" value="35000" id="lowercutoff" ></br>
			<input id="submitcutoff" type="submit" value="Submit" class="w3-button w3-black" >
	</div>

	<!-- legend-->
	<!--
	<div id='map-legend' class='legend'>
    <div><span style='background-color: #078393'></span>New Development</div>
    <div><span style='background-color: #5bb25b'></span>New Open Space</div>
    <div><span style='background-color: #333333'></span>Retained Parking</div>
	<div><span id="metro" style='color: #ea7820; font-style: bold;'>M</span>Metro stops</div>
	</div>
	-->




  </body>

  <!-- geojsondata =  -->
  <script type="text/javascript" src="data/podiumfix3.js "></script> <!--Floor_WBP_4326_over2m_tagged_BLDGUSE.jsFloor_WBP_4326_over2m_BLDGUSE.js -->
  <!-- building_data = -->
  <script type="text/javascript" src="data/buildings_data_190228.js"></script>
  <script type="text/javascript" src="colourScales.js"></script>
  <script type="text/javascript">

	//append options to property menu
	//Create and append the options


	var array_areas = [
				 "Area_Creative",
				 "Area_FnB",
				 "Area_HigherEd",
				 "Area_ICT",
				 "Area_LifeScience",
				 "Area_OtherOffice" ];
	var array_empl = [
				 "Total_Empl" ,
				 "Empl_Creative",
				 "Empl_HigherEd",
				 "Empl_ICT",
				 "Empl_LifeScience",
				 "Empl_OtherOffice"];
	var array_percentages = [
				 "Percent_Creative",
				 "Percent_FnB",
				 "Percent_HigherEd",
				 "Percent_ICT",
				 "Percent_LifeScience",
				 "Percent_OtherOffice"];
	var array_totals = [
				 "Total_Area",
				 "Total_Area_Office"
				 ];

	var array = array_totals;
	var selectList = document.getElementById('prop_total');
	/*
	for (var i = 0; i < array.length; i++) {
		var option = document.createElement("option");
		option.value = array[i];
		option.text = array[i];
		selectList.appendChild(option);
	}
	*/
	var options_str = "";
	array.forEach( function(p) {
	  options_str += '<option value="' + p + '">' + p + '</option>';
	});
	selectList.innerHTML = options_str;


	array = array_percentages;
	selectList = document.getElementById('prop_percentages');
	options_str = "";
	array.forEach( function(p) {
	  options_str += '<option value="' + p + '">' + p + '</option>';
	});
	selectList.innerHTML = options_str;

	array = array_empl;
	selectList = document.getElementById('prop_empl');
	options_str = "";
	array.forEach( function(p) {
	  options_str += '<option value="' + p + '">' + p + '</option>';
	});
	selectList.innerHTML = options_str;


	//filter geojsondata to remove PK MAJORUSE
	var tempgeojsondatafeatures = geojsondata.features.slice(0);
	geojsondata.features = [];
	$.each(tempgeojsondatafeatures, function(j,feature) {
		if(feature.properties.MAJORUSE!='PK') {
			geojsondata.features.push(feature);
		}
		else{
			console.log(("park at ").concat(j));
		}
	});

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++VARIABLES
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	var joinVar = ""; // "Total_Area_Office";

    mapboxgl.accessToken = 'pk.eyJ1IjoibDAwYnkiLCJhIjoiMDNmOTJjMDRlNThlY2UzYTUyMDY1YzM5YjAyZWJlM2IifQ.ZPZ1QAs1tk5OQgt4AwPrVw';

    const {MapboxLayer, GeoJsonLayer} = deck;

	const mapstyle1 = 'mapbox://styles/mapbox/light-v9';
	const mapstyle2 = 'mapbox://styles/l00by/cjo5ztvt412ei2rn1i57ulv8t';

	//const MAP_STYLE =  'mapbox://styles/l00by/cjnvt4k5o0i4q2sqnsrh20z8e'; //white and grey empty
	//const MAP_STYLE = 'mapbox://styles/l00by/cjo5ztvt412ei2rn1i57ulv8t'; //white and grey empty, trying to fix POI markers orange
	 var MAP_STYLE = mapstyle1;

	 //deck lighting
	 var LIGHT_SETTINGS2 = {
			lightsPosition: [0, 0, 8000,  -0.49*8000, -0.28*8000, 1*8000], //POLAR: [1.15,210,30],
			ambientRatio: 0.9,
			diffuseRatio: 0.25,
			specularRatio: 0.1,
			lightsStrength: [0.5, 0.5, 0.5, 0.5],
			numberOfLights: 2,
			coordinateOrigin: [151.1983490, -33.8847955, 0]
		}


	const COL_BUILDINGS = '#ffffff';//'#c4c4c4';
	const COL_BUILDINGS_NO_METRIC = '#c4c4c4';//'#ffffff';
	const COL_GREENSPACE = '#5bb25b'; //'#76d384';//'#d6d8d5',
	const COL_WATER = '#c7cbcc'; //'#a2c6d8'; //;
	const COL_WATER_SHADOW = '#aaaeaf'; //'#7aafc9'; //;
	const COL_VILLAGE_OUTLINES =  '#ffffff'; //'#0c0b3d';
	const COL_STUDYAREA_OUTLINE = '#000000';//'#ff0000';
	const COL_SITE_FILL = '#3a7ce8';

	DATA_URL_village_outlines = 'data/temp_villageOutlines_4326.geojson';
	//DATA_URL_buildings = 'data/buildings_geom_4326_noPK_XX.geojson';
	DATA_URL_site = 'data/temp_site_4326.geojson';
	DATA_URL_study_outline = 'data/temp_studyOutline_4326.geojson';
	DATA_URL_buildings_outside = 'data/temp_buildings_outsideStudy_4326.geojson';

	var whichView = 0;

	var viewsnormal = [
				//{"view": 'view 0', "camera": {center:[151.19816090006066,-33.88510494417777],zoom:14.302824376136305,bearing:0,pitch:0}},
				{"view": 'view 0', "camera": {center:[151.19816090006066,-33.88510494417777],zoom:14.302824376136305,bearing:0,pitch:0}},
				{"view": 'view 1', "camera": {center:[151.19669972384213,-33.886953314581575],zoom:14.302824376136305,bearing:0,pitch:50}},
				{"view": 'view 2', "camera": {center:[151.19766021867486,-33.887785766720974],zoom:14.60564875227261,bearing:-18.400000000000087,pitch:60}},
				/*{"view": 'view 3', "camera": {center:[151.20228432497413,-33.88408261091324],zoom:16.249138864624015,bearing:-18.400000000000087,pitch:60}},
				{"view": 'view 4', "camera": {center:[151.19863591624062,-33.88181337253056],zoom:14.993310444768726,bearing:25.59999999999991,pitch:37.00000000000001}},
				{"view": 'view 5', "camera": {center:[151.19324211713024,-33.884971940211834],zoom:14.708044264479904,bearing:77.59999999999991,pitch:53.000000000000014}},*/
				{"view": 'view 6', "camera": {center:[151.2020463487696,-33.8847335916916],zoom:15.464853142518923,bearing:-20,pitch:57.49999999999999}}
				];

	//3840 x 2160
	var viewsscreenshot = [
				{"view": 'screenshot 1', "camera": {center:[151.1984110825299,-33.8847103305664],zoom:14.945693344200944,bearing:0,pitch:0}},
				{"view": 'screenshot 2', "camera": {center:[151.1978663712539,-33.88614974443792],zoom:15.462292958410872,bearing:0,pitch:50}},
				{"view": 'screenshot 3', "camera": {center:[151.19961630515763,-33.88550343752285],zoom:15.635007247762104,bearing:-18.400000000000087,pitch:60}},
				{"view": 'screenshot 4', "camera": {center:[151.19992521325344,-33.885141421093344],zoom:15.721232583158708,bearing:-40.79999999999995,pitch:49.50000000000001}},
				{"view": 'screenshot 5', "camera": {center:[151.20140005719486,-33.88680529121602],zoom:16.170842085565024,bearing:-25.600000000000026,pitch:54}},
				{"view": 'screenshot closeup', "camera": {center:[151.20186989276158,-33.881408124860876],zoom:17.613510472575147,bearing:-9.59999999999991,pitch:60}}
	];

	var views = viewsscreenshot;
	const screenshotmultiply = 2;
	const forScreen = true;
	if(forScreen) {
		views = viewsscreenshot;
	}

	const map = new mapboxgl.Map({
      container: 'map-main',
      style: MAP_STYLE,
	  center: [151.1983490, -33.8847955],//[-118.248896, 34.03903672],//[-118.255896, 34.04203672],
      zoom: 14,
	  maxZoom: 18,
	  pitch: 50,
	  preserveDrawingBuffer: true
    });

//let geojsonLayer;

	//BUILDING VARS
	const CONST_floorHeight = 3.0;
	const CONST_maxFloors = 73;
	const COL_byHeight_1 = [0,0,100];//[0, 51, 135]; //[101, 74, 224];//[0,0,0]; //[255,255,255];
	const COL_byHeight_2 = [255,255,5];//[187, 211, 27]; //[247, 161, 42]; //[255,255,255];//[5,100,255];


	function takeScreenshot() {
		map.getCanvas().toBlob(function (blob) {
          saveAs(blob, 'map_test.png');
		  console.log('saved as map_test.png');
		  console.log(map.getZoom());
        })
	};

	function logCamera() {
		console.log('"camera": {center:[' +map.getCenter().lng + ',' + map.getCenter().lat+'],zoom:'+map.getZoom()+',bearing:'+map.getBearing()+',pitch:'+map.getPitch()+'}');
	};

	function switchView() {
		if(whichView<(views.length-1)) {
			whichView += 1;
		}
		else{
			whichView = 0;
		}
		map.flyTo(views[whichView].camera);
		document.getElementById('viewNumber').innerHTML = views[whichView].view;
	}

    map.on('load', () => {

		//change water color
		map.setPaintProperty('water', 'fill-color', COL_WATER);
		map.setPaintProperty('water shadow', 'fill-color', COL_WATER_SHADOW);
		map.setPaintProperty('waterway-river-canal', 'line-color', COL_WATER);
		//map.setPaintProperty('parks', 'fill-color', COL_GREENSPACE);
		//map.setPaintProperty('national_park', 'fill-color', COL_GREENSPACE);
		//hill shading
		/*
		map.addSource('dem', {
			"type": "raster-dem",
			"url": "mapbox://mapbox.terrain-rgb"
		});
		map.addLayer({
			"id": "hillshading",
			"source": "dem",
			"type": "hillshade"
		});
		*/

		//map.setLight({color: "#6ef", intensity: 0.5, position: [1.15, 135, 45]});
		//console.log(map.getLight());
		map.setLight({intensity: 0.4});


		//NBHD OUTLINE LAYERS
		map.addSource('Nbhds', {
            type: 'geojson',
			data: DATA_URL_village_outlines
        });


		//ADD NBHD OUTLINES TO MAPS
		nbhd_outline_layer = {
			'id': 'nbhd_outlines',
			'type': 'line',
			'source': 'Nbhds',
			'interactive': false,
			'layout': {},
			//"filter": [ 'any', ['in', 'BS'].concat([])],
			paint: {
					  'line-color': COL_VILLAGE_OUTLINES,
					  'line-opacity': 0.8,
					  'line-width': 1.5
					}
		};
		map.addLayer(nbhd_outline_layer);

		map.addSource('StudyArea', {
            type: 'geojson',
			data: DATA_URL_study_outline
        });

		study_outline_layer = {
			'id': 'study_outlines',
			'type': 'line',
			'source': 'StudyArea',
			'interactive': false,
			'layout': {},
			//"filter": [ 'any', ['in', 'BS'].concat([])],
			paint: {
					  'line-color': COL_STUDYAREA_OUTLINE,
					  'line-opacity': 0.8,
					  'line-width': 3*screenshotmultiply
					}
		};
		map.addLayer(study_outline_layer);

		map.addSource('Site', {
            type: 'geojson',
			data: DATA_URL_site
        });

		study_outline_layer = {
			'id': 'site_outline',
			'type': 'fill',
			'source': 'Site',
			'interactive': false,
			'layout': {},
			//"filter": [ 'any', ['in', 'BS'].concat([])],
			paint: {
					  'fill-color': COL_SITE_FILL,
					  'fill-opacity': 0.8
					}
		};
		map.addLayer(study_outline_layer);

		//ADD BUILDINGS OUTSIDE STUDY AREA
		map.addSource('BuildingsOutsideStudyArea', {
			type: 'geojson',
			data: DATA_URL_buildings_outside,
			buffer: 0,
			maxzoom: 18
		});

		map.addLayer({
				'id': 'buildingsOutsideStudyArea',
				'source': 'BuildingsOutsideStudyArea',
				'type': 'fill-extrusion',
				'paint': {
					//'fill-extrusion-color': colours[i],
					'fill-extrusion-color': COL_BUILDINGS,
					'fill-extrusion-height': ["get", "height"],
					'fill-extrusion-base': 0.0,
					'fill-extrusion-opacity': 0.9,
					'fill-extrusion-vertical-gradient': false //important if you want true colours: defaults to true
				}
			});



		//ADD BUILDINGS (FLOORS)

		//for each feature, for each coordinate - move Z value
		$.each(geojsondata.features, function(i,feature) {
				//console.log(feature.properties.FloorRL);
				//console.log(feature.geometry.type);
				if(feature.geometry.type=="Polygon") {
						$.each(feature.geometry.coordinates[0], function(j, coord) {
							//console.log('coord');
							//console.log(coord);
							var newCoord = [coord[0], coord[1], feature.properties.FloorRL];
							feature.geometry.coordinates[0][j] = newCoord;
							//console.log(coord);
						});
				}
				 else if(feature.geometry.type=="MultiPolygon") {
					$.each(feature.geometry.coordinates, function(j, coords) {
						$.each(coords[0], function(k, coord) {
							//console.log('coord');
							//console.log(coord);
							var newCoord = [coord[0], coord[1], feature.properties.FloorRL];
							feature.geometry.coordinates[j][0][k] = newCoord;
							//console.log(coord);
						});
					});
				}
		});

		joinVar = document.getElementById('prop_total').value;

		joinDataAndAddLayer(map, joinVar, cutoffvalue);

		addEventListenerToPropTotal();

		addEventListenerToPropPercentages();

		addEventListenerToPropEmpl();

    });

	function addEventListenerToPropTotal() {

		var prop = document.getElementById('prop_total');
        prop.addEventListener('change', function() {

			if(prop.value!=joinVar) {
				joinVar = prop.value;
				joinDataAndAddLayer(map, joinVar, cutoffvalue);
			}
        })
	}

	function addEventListenerToPropPercentages() {

		var prop = document.getElementById('prop_percentages');
        prop.addEventListener('change', function() {

			if(prop.value!=joinVar) {
				joinVar = prop.value;
				joinDataAndAddPercentagesLayer(map, joinVar);
			}
        })
	}

	function addEventListenerToPropEmpl() {

		var prop = document.getElementById('prop_empl');
        prop.addEventListener('change', function() {

			if(prop.value!=joinVar) {
				joinVar = prop.value;
				joinDataAndAddEmplLayer(map, joinVar);
			}
        })
	}

	function addLayerNLA() {

		if(map.getLayer('floors')!=undefined) {
			//console.log("floors layer exists so remove it");
			map.removeLayer('floors');
		}
		else{
			//console.log("floors layer doesn't exist");
		}

		//MAKE LAYER:
		var geojsonLayer = new MapboxLayer({
			type: GeoJsonLayer,
			id: 'floors',
			data: geojsondata, //'data_ss/Floors_WBP_geom_4326.geojson', //floors_minitest_3D_4326.geojson', // '181008_downtown_plots_4326.geojson',
			opacity: 0.6,
			stroked: false,
			filled: true,
			extruded: true,
			wireframe: true,
			fp64: false,
			lightSettings: LIGHT_SETTINGS2,
			getElevation: f => f.properties.FloorHeight,
			getFillColor: f => COLOURSCALE_NLA(f.properties.Shape_Area),//COLOURSCALE_CUTOFF(f.properties.val, cutoffvalue),
			getLineColor: f => COLOURSCALE_NLA_darker(f.properties.Shape_Area),//COLOURSCALE_CUTOFF_darker(f.properties.val, cutoffvalue),
			lineWidthMaxPixels: 1,
			lineWidthMinPixels: 1,
			pickable: true,
			updateTriggers: {
				//lightSettings: console.log('update lightSettings')
				getFillColor: { c1: cutoffvalue},
				getLineColor: { c1: cutoffvalue}
			}
			//onHover: updateTooltip
		});

		//ADD LAYER:
		map.addLayer(geojsonLayer);

	}



	function addLayerMAJORUSE() {

		if(map.getLayer('floors')!=undefined) {
			//console.log("floors layer exists so remove it");
			map.removeLayer('floors');
		}
		else{
			//console.log("floors layer doesn't exist");
		}

		//MAKE LAYER:
		var geojsonLayer = new MapboxLayer({
			type: GeoJsonLayer,
			id: 'floors',
			data: geojsondata, //'data_ss/Floors_WBP_geom_4326.geojson', //floors_minitest_3D_4326.geojson', // '181008_downtown_plots_4326.geojson',
			opacity: 0.6,
			stroked: false,
			filled: true,
			extruded: true,
			wireframe: true,
			fp64: false,
			lightSettings: LIGHT_SETTINGS2,
			getElevation: f => f.properties.FloorHeight,
			getFillColor: f => COLOURSCALE_USE(f.properties.MAJORUSE),//COLOURSCALE_CUTOFF(f.properties.val, cutoffvalue),
			getLineColor: f => COLOURSCALE_USE_darker(f.properties.MAJORUSE),//COLOURSCALE_CUTOFF_darker(f.properties.val, cutoffvalue),
			lineWidthMaxPixels: 1,
			lineWidthMinPixels: 1,
			pickable: true,
			updateTriggers: {
				//lightSettings: console.log('update lightSettings')
				getFillColor: { c1: cutoffvalue},
				getLineColor: { c1: cutoffvalue}
			}
			//onHover: updateTooltip
		});

		//ADD LAYER:
		map.addLayer(geojsonLayer);

	}



	function addLayerSATISFIED() {

		if(map.getLayer('floors')!=undefined) {
			//console.log("floors layer exists so remove it");
			map.removeLayer('floors');
		}
		else{
			//console.log("floors layer doesn't exist");
		}

		//MAKE LAYER:
		var geojsonLayer = new MapboxLayer({
			type: GeoJsonLayer,
			id: 'floors',
			data: geojsondata, //'data_ss/Floors_WBP_geom_4326.geojson', //floors_minitest_3D_4326.geojson', // '181008_downtown_plots_4326.geojson',
			opacity: 0.6,
			stroked: false,
			filled: true,
			extruded: true,
			wireframe: true,
			fp64: false,
			lightSettings: LIGHT_SETTINGS2,
			getElevation: f => f.properties.FloorHeight,
			getFillColor: f => COLOURSCALE_SATISFIED(f.properties.satisfied_all),//COLOURSCALE_CUTOFF(f.properties.val, cutoffvalue),
			getLineColor: f => COLOURSCALE_SATISFIED_darker(f.properties.satisfied_all),//COLOURSCALE_CUTOFF_darker(f.properties.val, cutoffvalue),
			lineWidthMaxPixels: 1,
			lineWidthMinPixels: 1,
			pickable: true,
			updateTriggers: {
				//lightSettings: console.log('update lightSettings')
				getFillColor: { c1: cutoffvalue},
				getLineColor: { c1: cutoffvalue}
			}
			//onHover: updateTooltip
		});

		//ADD LAYER:
		map.addLayer(geojsonLayer);

	}

	function addLayerPODIUM() {

		if(map.getLayer('floors')!=undefined) {
			//console.log("floors layer exists so remove it");
			map.removeLayer('floors');
		}
		else{
			//console.log("floors layer doesn't exist");
		}

		//MAKE LAYER:
		var geojsonLayer = new MapboxLayer({
			type: GeoJsonLayer,
			id: 'floors',
			data: geojsondata, //'data_ss/Floors_WBP_geom_4326.geojson', //floors_minitest_3D_4326.geojson', // '181008_downtown_plots_4326.geojson',
			opacity: 0.6,
			stroked: false,
			filled: true,
			extruded: true,
			wireframe: true,
			fp64: false,
			lightSettings: LIGHT_SETTINGS2,
			getElevation: f => f.properties.FloorHeight,
			getFillColor: f => COLOURSCALE_PODIUM(f.properties.typology),//COLOURSCALE_CUTOFF(f.properties.val, cutoffvalue),
			getLineColor: f => COLOURSCALE_PODIUM_darker(f.properties.typology),//COLOURSCALE_CUTOFF_darker(f.properties.val, cutoffvalue),
			lineWidthMaxPixels: 1,
			lineWidthMinPixels: 1,
			pickable: true,
			updateTriggers: {
				//lightSettings: console.log('update lightSettings')
				getFillColor: { c1: cutoffvalue},
				getLineColor: { c1: cutoffvalue}
			}
			//onHover: updateTooltip
		});

		//ADD LAYER:
		map.addLayer(geojsonLayer);

	}

	function joinDataAndAddPercentagesLayer(map, joinVar) {

		if(map.getLayer('floors')!=undefined) {
			//console.log("floors layer exists so remove it");
			map.removeLayer('floors');
		}
		else{
			//console.log("floors layer doesn't exist");
		}

		//JOIN DATA:
		var joinKey = "BUILDINGKEY";
		$.each(geojsondata.features, function(j,feature) {
			//feature.properties[joinKey] = 'B'.concat(feature.properties["BuildingKey"])
			var val = 0;
			var keyVal = feature.properties[joinKey];
			for (var i = 0; i < building_data.length; i++) {
				if (building_data[i][joinKey] == keyVal) {
					val = building_data[i][joinVar];
				}
			}
			feature.properties.val = val;
		});

		//MAKE LAYER:
		var geojsonLayer = new MapboxLayer({
			type: GeoJsonLayer,
			id: 'floors',
			data: geojsondata, //'data_ss/Floors_WBP_geom_4326.geojson', //floors_minitest_3D_4326.geojson', // '181008_downtown_plots_4326.geojson',
			opacity: 0.6,
			stroked: false,
			filled: true,
			extruded: true,
			wireframe: true,
			fp64: false,
			lightSettings: LIGHT_SETTINGS2,
			getElevation: f => f.properties.FloorHeight,
			getFillColor: f => COLOURSCALE_PERCENT(f.properties.val),
			getLineColor: f => COLOURSCALE_PERCENT_darker(f.properties.val),
			lineWidthMaxPixels: 1,
			lineWidthMinPixels: 1,
			pickable: true,
			updateTriggers: {
				//lightSettings: console.log('update lightSettings')
				getFillColor: { c1: cutoffvalue},
				getLineColor: { c1: cutoffvalue}
			}
			//onHover: updateTooltip
		});

		//ADD LAYER:
		map.addLayer(geojsonLayer);

	}

	function joinDataAndAddEmplLayer(map, joinVar) {

		if(map.getLayer('floors')!=undefined) {
			//console.log("floors layer exists so remove it");
			map.removeLayer('floors');
		}
		else{
			//console.log("floors layer doesn't exist");
		}

		//JOIN DATA:
		var joinKey = "BUILDINGKEY";
		$.each(geojsondata.features, function(j,feature) {
			//feature.properties[joinKey] = 'B'.concat(feature.properties["BuildingKey"])
			var val = 0;
			var keyVal = feature.properties[joinKey];
			for (var i = 0; i < building_data.length; i++) {
				if (building_data[i][joinKey] == keyVal) {
					val = building_data[i][joinVar];
				}
			}
			feature.properties.val = val;
		});

		//MAKE LAYER:
		var geojsonLayer = new MapboxLayer({
			type: GeoJsonLayer,
			id: 'floors',
			data: geojsondata, //'data_ss/Floors_WBP_geom_4326.geojson', //floors_minitest_3D_4326.geojson', // '181008_downtown_plots_4326.geojson',
			opacity: 0.6,
			stroked: false,
			filled: true,
			extruded: true,
			wireframe: true,
			fp64: false,
			lightSettings: LIGHT_SETTINGS2,
			getElevation: f => f.properties.FloorHeight,
			getFillColor: f => COLOURSCALE_EMPLOYEES(f.properties.val),
			getLineColor: f => COLOURSCALE_EMPLOYEES_darker(f.properties.val),
			lineWidthMaxPixels: 1,
			lineWidthMinPixels: 1,
			pickable: true,
			updateTriggers: {
				//lightSettings: console.log('update lightSettings')
				getFillColor: { c1: cutoffvalue},
				getLineColor: { c1: cutoffvalue}
			}
			//onHover: updateTooltip
		});

		//ADD LAYER:
		map.addLayer(geojsonLayer);

	}

	function joinDataAndAddLayer(map, joinVar, cutoffvalue) {

		if(map.getLayer('floors')!=undefined) {
			//console.log("floors layer exists so remove it");
			map.removeLayer('floors');
		}
		else{
			//console.log("floors layer doesn't exist");
		}

		//JOIN DATA:
		var joinKey = "BUILDINGKEY";
		$.each(geojsondata.features, function(j,feature) {
			//feature.properties[joinKey] = 'B'.concat(feature.properties["BuildingKey"])
			var val = 0;
			var keyVal = feature.properties[joinKey];
			for (var i = 0; i < building_data.length; i++) {
				if (building_data[i][joinKey] == keyVal) {
					val = building_data[i][joinVar];
				}
			}
			feature.properties.val = val;
		});

		//MAKE LAYER:
		var geojsonLayer = new MapboxLayer({
			type: GeoJsonLayer,
			id: 'floors',
			data: geojsondata, //'data_ss/Floors_WBP_geom_4326.geojson', //floors_minitest_3D_4326.geojson', // '181008_downtown_plots_4326.geojson',
			opacity: 0.6,
			stroked: false,
			filled: true,
			extruded: true,
			wireframe: true,
			fp64: false,
			lightSettings: LIGHT_SETTINGS2,
			getElevation: f => f.properties.FloorHeight,
			getFillColor: f => COLOURSCALE_CUTOFF(f.properties.val, cutoffvalue),
			getLineColor: f => COLOURSCALE_CUTOFF_darker(f.properties.val, cutoffvalue),
			lineWidthMaxPixels: 1,
			lineWidthMinPixels: 1,
			pickable: true,
			updateTriggers: {
				//lightSettings: console.log('update lightSettings')
				getFillColor: { c1: cutoffvalue},
				getLineColor: { c1: cutoffvalue}
			}
			//onHover: updateTooltip
		});

		//ADD LAYER:
		map.addLayer(geojsonLayer);

	}

	/*=================================================*/
	document.getElementById("submitcutoff").onclick = function () { updateCutoff(); };

	var cutoffvalue = document.getElementById('lowercutoff').value;

	function updateCutoff() {

		cutoffvalue = document.getElementById('lowercutoff').value;
		console.log("submit cutoff ".concat(cutoffvalue));

		joinDataAndAddLayer(map, joinVar, cutoffvalue);

	}
	/*==================================================*/


	function updateFillExtrusionByNoValue() {
		var colour = COL_BUILDINGS_NO_METRIC;
		map.setPaintProperty(('footprints'), 'fill-extrusion-color', colour);

	}

	function updateFillExtrusionByHeight() {

		//var colour = interpolateHSLColorAsString(COL_byHeight_1, COL_byHeight_2, CONST_maxFloors, LEVELSABOVEGROUND); //interpolateRGBColorAsString(COL_byHeight_1, COL_byHeight_2, CONST_maxFloors, i);

		var col_stops = [];

		for (var i = 1; i <= CONST_maxFloors; i++) {
		   col_stops.push([i, interpolateHSLColorAsString(COL_byHeight_1, COL_byHeight_2, CONST_maxFloors, i)]);
		}

		map.setPaintProperty(('footprints'), 'fill-extrusion-color', {
						property: 'LEVELSABOVEGROUND',
						stops: col_stops
		});

	}

	function updateFillExtrusionColorByFloorplateArea(IN_RANGE) {
		if(IN_RANGE) {
			for (i = 1; i <= CONST_maxFloors; i++) {
			map.setPaintProperty(('floor'+i), 'fill-extrusion-color', {
					property: 'area',
					stops: [
								[0, COL_BUILDINGS_NO_METRIC],
								[1000, COL_BUILDINGS_NO_METRIC],
								[1500, COL_BUILDINGS_NO_METRIC],
								[2000, COL_BUILDINGS_NO_METRIC],
								[3000, '#f03b20'],
								[100000, '#bd0026']
							]

				});
			}
		}
		else{ //if 'not in range'
			for (i = 1; i <= CONST_maxFloors; i++) {
				map.setPaintProperty(('floor'+i), 'fill-extrusion-color', {
						property: 'area',
						stops: [
									[0, '#ffffb2'],
									[1000, '#fed976'],
									[1500, '#feb24c'],
									[2000, '#fd8d3c'],
									[3000, '#f03b20'],
									[100000, '#bd0026']
								]

					});
				}
			}
	}

	/* NOT WORKING
	function updateFillExtrusionColorByTotalArea() {
		for (i = 1; i <= CONST_maxFloors; i++) {
			map.setPaintProperty(('floor'+i), 'fill-extrusion-color', {
					property: ["get", "height"], //['*', ['get', 'area'], ['/', ['get', 'height'], CONST_floorHeight]],
					stops: [
							[0, '#ffffcc'],
							[10000, '#d9f0a3'],
							[20000, '#addd8e'],
							[35000, '#78c679'],
							[40000, '#31a354'],
							[1000000, '#006837']
							]

				});
		}
	}
	*/

	// adapted from: https://codepen.io/njmcode/pen/axoyD/
	// Interpolates two [r,g,b] colors and returns an [r,g,b] of the result
	// Taken from the awesome ROT.js roguelike dev library at
	// https://github.com/ondras/rot.js
	function interpolateRGBColor(color1, color2, numberSteps, step) {
	  var result = color1;
	  var factor = step*1.0/(numberSteps*1.0);
	  for (var j=0;j<3;j++) {
		result[j] = Math.round(color1[j] + factor*(color2[j]-color1[j]));
	  }
	  return result;
	};

	function interpolateRGBColorAsString(color1, color2, numberSteps, step) {
		var col = interpolateRGBColor(color1, color2, numberSteps, step);
		return ('rgb('+col[0]+','+col[1]+','+col[2]+')');
	}

	function interpolateHSLColor(color1, color2, numberSteps, step) {
	  var hslColor1 = rgb2hsl(color1);
	  var hslColor2 = rgb2hsl(color2);
	  var result = hslColor1;
	  var factor = step*1.0/(numberSteps*1.0);
	  for (var j=0;j<3;j++) {
		result[j] = (hslColor1[j] + factor*(hslColor2[j]-hslColor1[j]));
	  }
	  return hsl2rgb(result);
	};

	function interpolateHSLColorAsString(color1, color2, numberSteps, step) {
		var col = interpolateHSLColor(color1, color2, numberSteps, step);
		return ('rgb('+col[0]+','+col[1]+','+col[2]+')');
	}

	/**
	 * Converts an RGB color value to HSL. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes r, g, and b are contained in the set [0, 255] and
	 * returns h, s, and l in the set [0, 1].
	 *
	 * @param   {number}  r       The red color value
	 * @param   {number}  g       The green color value
	 * @param   {number}  b       The blue color value
	 * @return  {Array}           The HSL representation
	 */
	function rgb2hsl(col){

		r=col[0]; g=col[1]; b=col[2];
		//console.log("rgb: "+r+","+g+","+b);
		r /= 255, g /= 255, b /= 255;
		var max = Math.max(r, g, b), min = Math.min(r, g, b);
		var h, s, l = (max + min) / 2;

		if(max == min){
			h = s = 0; // achromatic
		}else{
			var d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			switch(max){
				case r: h = (g - b) / d + (g < b ? 6 : 0); break;
				case g: h = (b - r) / d + 2; break;
				case b: h = (r - g) / d + 4; break;
			}
			h /= 6;
		}
		//console.log("to hsl: "+h+","+s+","+l);
		return ([h, s, l]);
	}

	/**
	 * Converts an HSL color value to RGB. Conversion formula
	 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
	 * Assumes h, s, and l are contained in the set [0, 1] and
	 * returns r, g, and b in the set [0, 255].
	 *
	 * @param   {number}  h       The hue
	 * @param   {number}  s       The saturation
	 * @param   {number}  l       The lightness
	 * @return  {Array}           The RGB representation
	 */
	function hsl2rgb(colhsl){

		h = colhsl[0]; s = colhsl[1]; l = colhsl[2];
		//console.log("hsl: "+h+","+s+","+l);
		var r, g, b;

		if(s == 0){
			r = g = b = l; // achromatic
		}else{
			var hue2rgb = function hue2rgb(p, q, t){
				if(t < 0) t += 1;
				if(t > 1) t -= 1;
				if(t < 1/6) return p + (q - p) * 6 * t;
				if(t < 1/2) return q;
				if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
				return p;
			}

			var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
			var p = 2 * l - q;
			r = hue2rgb(p, q, h + 1/3);
			g = hue2rgb(p, q, h);
			b = hue2rgb(p, q, h - 1/3);
		}
		//console.log("to rgb: "+Math.round(r * 255)+","+Math.round(g * 255)+","+Math.round(b * 255));
		return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
	}

  </script>
</html>
